# Package management

- It's possible to manage all aspects of software such as installation, configuration, upgrade, and uninstall.
- Benefits:
  - Reusability: reuse same package in multiple solutions
  - Download a package into your solution whenever required.
  - Leads to faster development
- Issues with public package managers
  - Maintaining governance and control
    - E.g. people can use different versions of packages
  - Security
    - Does it have loopholes? Concerns?
    - Developer can use any package to ensure application works.
- Need for managing dependencies
  - Applications can just get swarmed into using application dependencies
  - There can be no control over the packages being used in application
  - Security can also be concern when you are looking at working with public packages

## Some package managers

- `apt` for Debian Linux environments
- `yum` for CentOS Linux environments.
- `Chocolatey`: software management solution built on PowerShell for Windows operating systems.
- [**`nuget`**](https://www.nuget.org/) for .NET applications
- [**`npm`**](https://www.npmjs.com/) for JavaScript packages
  - `package.json`
    - resides in project root folder
    - lists the packages your project depends on
    - specifies versions of a package that your project can use using [semantic versioning rules](https://docs.npmjs.com/about-semantic-versioning)
    - makes your build reproducible, and therefore easier to share with other developers
  - `.npmrc`
    - `npm` gets its config settings from the command line, environment variables, and `npmrc` files.
    - Can be defined as
      - per-user: in home directory of the user (`$HOME/.npmrc`)
      - per-project: project root (`$PREFIX/etc/npmrc`)
      - global: `$PREFIX/etc/npmrc`
      - built-in: unchangeable, in `path/to/npm/itself/npmrc`
    - Azure DevOps Services [recommends](https://docs.microsoft.com/en-us/azure/devops/artifacts/npm/npmrc?view=azure-devops&tabs=windows#where-are-my-npmrc-files) using two `.npmrc` files:
      1. One `.npmrc` should live at the root of your git repo adjacent to your project's `package.json`.
         - Should define registries
      2. On the development machine, `.npmrc` in `$home` for Linux or Mac systems or `$env.HOME` for win systems
         - Should contain credentials for all of the registries that you need to connect to.
         - ðŸ’¡ The NPM client will look at your project's `.npmrc`, discover the registry, and fetch matching credentials from `$home/.npmrc` or `$env.HOME/.npmrc`
         - I[n build task, you give credentials in [`npm Authenticate` task](https://docs.microsoft.com/en-us/azure/devops/artifacts/npm/npmrc?view=azure-devops&tabs=windows#set-up-authentication-on-your-dev-box)
- [**`maven`**](https://maven.apache.org/): most popular build and dependency resolution tool for Java
  - [**`gradle`**](https://maven.apache.org/) is a Java build tool that can use Maven or Ivy repositories for dependency resolution.

## Security and Compliance

- Developers make use of publicly available packages on the Internet
- Security concerns: Are all security vulnerabilities addressed?
- Licensing problems: e.g. some licenses if you change the code in the package you must make the package publicly available.
- **Tools and Integration**
  - [BlackDuck by Synopsys](https://www.synopsys.com/software-integrity/security-testing/software-composition-analysis.html)
    - Scan all open source dependencies in your application
    - Get issues reported on all possible security vulnerabilities
  - [WhiteSource Bolt](https://www.whitesourcesoftware.com/)
    - tool for scanning open-source dependencies for vulnerabilities and licensing
  - [GitHub Advanced Security](https://docs.github.com/en/code-security): Integrated security scanning
    - Secret scanning and dependency review
    - CodeQL semantic analysis
  - **Azure DevOps Integration**: Extensions for automated security scanning
    - Service connections for external scanners
    - Pipeline tasks for vulnerability assessment

## Versioning Strategies (2025)

### Semantic Versioning (SemVer)

- **Format**: `MAJOR.MINOR.PATCH`
  - **MAJOR**: Breaking changes
  - **MINOR**: New features (backward compatible)
  - **PATCH**: Bug fixes (backward compatible)
- **Pre-release Tags**: `1.0.0-alpha`, `1.0.0-beta.1`
- **Build Metadata**: `1.0.0+build.5`

### Calendar Versioning (CalVer)

- **Format**: `YYYY.MINOR.PATCH`
  - Example: `2025.1.0` (January 2025, first release)
- **Benefits**: Easy to identify release age
- **Use Cases**: Long-lived products, annual releases

### Versioning Best Practices

- **Consistent Versioning**: Apply across all packages in organization
- **Automated Versioning**: Include in CI/CD pipelines
- **Release Tags**: Tag releases in Git for traceability
- **Changelog**: Maintain automated release notes

## GitHub Packages Integration (2025)

### Unified Package Management

- **GitHub Packages**: Native package registry for GitHub
  - Supports npm, NuGet, Maven, RubyGems, Container images
  - Integrated with GitHub Actions workflows
  - Free for public repositories, paid for private

### Azure Artifacts vs GitHub Packages

| Feature | Azure Artifacts | GitHub Packages |
|---------|----------------|-----------------|
| **Integration** | Azure DevOps | GitHub |
| **Authentication** | PAT, Entra ID | PAT, OIDC |
| **Scanning** | External tools | Built-in Advanced Security |
| **Upstream Sources** | Yes | Limited support |

### Best Practices

- **Upstream Sources**: Configure upstream registries for package discovery
- **Retention Policies**: Manage package lifecycle automatically
- **Proxy Support**: Use private feeds to control access to public packages
- **Version Locking**: Pin versions in production deployments
- **Package Provenance**: Verify package authenticity
